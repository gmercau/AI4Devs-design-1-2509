LTI es un ATS de nueva generaci√≥n que combina automatizaci√≥n, inteligencia y experiencia humana.
Reduce costos y tiempos, mejora la precisi√≥n de contrataci√≥n y convierte el proceso de reclutamiento en un flujo continuo, medible y escalable.

üß© 1. Descripci√≥n general, valor a√±adido y ventajas competitivas
Descripci√≥n breve de LTI

LTI (Lean Talent Intelligence) es una plataforma de reclutamiento inteligente dise√±ada para optimizar todo el ciclo de contrataci√≥n ‚Äîdesde la publicaci√≥n de vacantes hasta la selecci√≥n final‚Äî utilizando inteligencia artificial para automatizar tareas, mejorar la precisi√≥n del matching y ofrecer una experiencia superior tanto a reclutadores como candidatos.

Est√° pensada para empresas medianas y grandes que buscan reducir tiempos de contrataci√≥n, mejorar la calidad del talento incorporado y fortalecer su marca empleadora.

Valor a√±adido

Automatizaci√≥n total del proceso: LTI elimina tareas repetitivas como screening de CVs, clasificaci√≥n y comunicaci√≥n inicial.

Contrataciones m√°s acertadas: modelos de IA que predicen el ‚Äúfit‚Äù cultural y t√©cnico del candidato.

Datos que impulsan decisiones: anal√≠tica predictiva para anticipar tiempos, costos y desempe√±o futuro.

Experiencia moderna: candidatos informados, comunicados y acompa√±ados durante todo el proceso.


Ventajas competitivas
| Categor√≠a                                | Ventaja                                                         | Resultado                              |
| ---------------------------------------- | --------------------------------------------------------------- | -------------------------------------- |
| **IA aplicada al matching**              | B√∫squeda sem√°ntica y scoring predictivo                         | M√°s precisi√≥n y velocidad en selecci√≥n |
| **Automatizaci√≥n integral**              | Screening, comunicaci√≥n y gesti√≥n del pipeline                  | Ahorro de tiempo operativo (hasta 50%) |
| **An√°lisis predictivo**                  | Identifica cuellos de botella y predice contrataciones exitosas | Mejora continua del proceso            |
| **UX para reclutadores y candidatos**    | Interfaces limpias, chatbots y feedback automatizado            | Aumenta engagement y retenci√≥n         |
| **Integraci√≥n con ecosistemas HR y CRM** | APIs abiertas y plug-ins con herramientas existentes            | Adopci√≥n r√°pida y baja fricci√≥n        |
| **Aprendizaje continuo**                 | Modelos de IA que se ajustan con cada contrataci√≥n              | Precisi√≥n creciente en el tiempo       |


‚öôÔ∏è 2. Funciones principales

A continuaci√≥n, las funciones clave de LTI ordenadas por prioridad y valor para el usuario:

| M√≥dulo                          | Funcionalidad                                      | Descripci√≥n                                                        | Beneficio                           |
| ------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------ | ----------------------------------- |
| **Gesti√≥n de Vacantes**         | Redacci√≥n asistida                                 | Generaci√≥n autom√°tica de descripciones inclusivas y atractivas     | Mejora la atracci√≥n de talento      |
| **Gesti√≥n de Candidatos**       | Parsing de CV e identificaci√≥n de skills           | Extrae y clasifica datos de curr√≠culums                            | Reduce trabajo manual y errores     |
| **Pipeline Inteligente**        | Scoring predictivo y priorizaci√≥n                  | Ordena candidatos seg√∫n ‚Äúfit‚Äù t√©cnico y cultural                   | Acelera decisiones y mejora calidad |
| **Captura de Postulaciones**    | Clasificaci√≥n autom√°tica y detecci√≥n de duplicados | Agrupa y depura postulaciones                                      | Optimiza el flujo de trabajo        |
| **Comunicaci√≥n con Candidatos** | Chatbot y respuestas autom√°ticas                   | Comunicaci√≥n 24/7 personalizada                                    | Mejora experiencia y engagement     |
| **B√∫squeda Sem√°ntica**          | Matching avanzado por contexto                     | Encuentra candidatos relevantes aunque no coincidan palabras clave | Incrementa precisi√≥n                |
| **Analytics & Dashboard**       | KPIs, predicciones y alertas inteligentes          | M√©tricas de tiempo de contrataci√≥n, costos y desempe√±o             | Decisiones basadas en datos         |
| **Cumplimiento y Privacidad**   | Control de consentimiento y auditor√≠a              | Monitoreo autom√°tico de cumplimiento legal                         | Disminuye riesgo normativo          |
| **Integraciones**               | Con HRIS, CRM y herramientas de video entrevistas  | APIs est√°ndar y conectores predefinidos                            | Simplifica la adopci√≥n              |
| **Experiencia del Candidato**   | Portal interactivo y feedback autom√°tico           | Gu√≠a personalizada durante el proceso                              | Refuerza marca empleadora           |


## üìä 3. Lean Canvas de LTI

| **Bloque**                     | **Descripci√≥n**                                                                 |
|-------------------------------|---------------------------------------------------------------------------------|
| **1. Problema**               | Procesos de reclutamiento lentos y manuales; dificultad para filtrar candidatos relevantes; experiencia deficiente para postulantes; falta de m√©tricas y visibilidad en el proceso. |
| **2. Segmentos de clientes**  | Empresas medianas y grandes (50+ empleados); consultoras de RRHH y *headhunters*; startups en crecimiento con alto volumen de contrataci√≥n. |
| **3. Propuesta de valor √∫nica** | **‚ÄúContrat√° mejor y m√°s r√°pido con inteligencia.‚Äù** LTI automatiza la b√∫squeda, evaluaci√≥n y selecci√≥n de talento mediante IA, mejorando calidad, velocidad y experiencia en el reclutamiento. |
| **4. Soluci√≥n**               | IA para *parsing* y *scoring* de CVs; *matching* sem√°ntico y predicci√≥n de desempe√±o; comunicaci√≥n automatizada con candidatos; anal√≠tica predictiva y *dashboards* de rendimiento. |
| **5. Canales**                | Ventas directas B2B; marketing de contenidos (*inbound*) en RRHH, talento e IA; integraciones con LinkedIn, Workday y SAP SuccessFactors; alianzas con firmas de reclutamiento. |
| **6. Fuentes de ingresos**    | Suscripci√≥n SaaS (mensual/anual); planes escalables por usuarios o vacantes activas; *add-ons* premium (IA avanzada, integraciones especializadas, anal√≠tica extendida). |
| **7. Estructura de costos**   | Desarrollo y mantenimiento del software; entrenamiento de modelos de IA; infraestructura en la nube; equipo de ventas y marketing B2B; soporte y capacitaci√≥n al cliente. |
| **8. M√©tricas clave (KPIs)**  | Tasa de adopci√≥n y retenci√≥n; tiempo promedio de contrataci√≥n (*Time-to-Hire*); porcentaje de tareas automatizadas; NPS de reclutadores y candidatos. |
| **9. Ventaja injusta**        | Modelos de IA entrenados con datos reales de contrataciones exitosas; motor de *matching* sem√°ntico propio optimizado para espa√±ol y portugu√©s; interfaz intuitiva para reclutadores no t√©cnicos. |

### los 3 casos de uso principales que sostienen la funcionalidad b√°sica del sistema son los siguientes:

üéØ 1. Gestionar Vacante
üí° Descripci√≥n

Permite a un reclutador crear, editar y publicar una vacante.
Inicia el flujo de reclutamiento: define el puesto, genera una descripci√≥n (con IA si est√° disponible) y publica la oferta en diferentes canales.

üë§ Actores

Reclutador (principal)

Sistema de IA (secundario)

Plataformas externas (LinkedIn, portales, etc.)

üß≠ Flujo principal

El reclutador selecciona ‚ÄúCrear nueva vacante‚Äù.

Ingresa los datos b√°sicos: t√≠tulo, descripci√≥n, requisitos, beneficios.

El sistema de IA sugiere mejoras en la redacci√≥n.

El reclutador aprueba y publica la vacante.

El sistema distribuye la oferta a los canales seleccionados.

üìò Diagrama UML ‚Äì Caso de uso: Gestionar Vacante

[Ver diagrama del caso de uso](images/caso_uso_gestionar_vacante.png)


üéØ 2. Evaluar Candidatos (Pipeline de Selecci√≥n)
üí° Descripci√≥n

El reclutador revisa los candidatos postulados a una vacante, analiza su perfil (parsing + scoring) y los mueve entre etapas del pipeline (preselecci√≥n, entrevista, oferta, contratado).

üë§ Actores

Reclutador (principal)

Sistema de IA (secundario)

Candidato (secundario)

üß≠ Flujo principal

El sistema muestra candidatos recibidos para una vacante.

La IA analiza los CVs y asigna un puntaje (fit t√©cnico/cultural).

El reclutador visualiza el pipeline y filtra candidatos por etapa o score.

El reclutador actualiza el estado de los candidatos.

El sistema notifica al candidato los avances.

üìò Diagrama UML ‚Äì Caso de uso: Evaluar Candidatos

[Ver diagrama del caso de uso](images/caso_uso_evaluar_candidatos.png)


üéØ 3. Comunicaci√≥n con Candidatos
üí° Descripci√≥n

El sistema gestiona la comunicaci√≥n con los postulantes de forma autom√°tica y personalizada.
Incluye respuestas a postulaciones, seguimiento de etapas y notificaci√≥n de resultados.

üë§ Actores

Candidato (principal)

Reclutador (secundario)

Chatbot / M√≥dulo de mensajer√≠a (sistema)

üß≠ Flujo principal

El candidato se postula a una vacante.

El sistema confirma la recepci√≥n autom√°tica.

A medida que el reclutador actualiza el estado, el sistema env√≠a mensajes o emails de actualizaci√≥n.

El candidato puede consultar su estado en el portal.

üìò Diagrama UML ‚Äì Caso de uso: Comunicaci√≥n con Candidatos

[Ver diagrama del caso de uso](images/caso_uso_comunicacion_con_candidatos.png)



### Modelo de datos

## User (Reclutador / Hiring Manager / Admin)

Campos esenciales:
- `id` (UUID)
- `nombre`
- `email` (√∫nico)
- `role` (recruiter, hiring_manager, admin)
- `timezone`
- `avatar_url`
- `created_at`
- `last_login`

Relaciones:
- User 1 ‚Äî * Vacancy (crea / gestiona)
- User 1 ‚Äî * Application (asignado a candidaturas)
- User 1 ‚Äî * Interview (entrevistador)
- User 1 ‚Äî * Offer (quien emite la oferta)

---

## Stage (etapa del pipeline ‚Äî reusable o por vacante)

Campos esenciales:
- `id` (UUID)
- `name` (e.g., screening, phone, on-site, offer)
- `order` (int)
- `vacancy_id` (FK nullable) ‚Äî si es espec√≠fica de vacante
- `is_default` (bool)

Relaciones:
- Vacancy 1 ‚Äî * Stage
- `Application.current_stage` -> Stage

---

## ApplicationHistory / ApplicationEvent (auditor√≠a de cambios de estado)

Campos esenciales:
- `id` (UUID)
- `application_id` (FK)
- `from_stage_id` (FK nullable)
- `to_stage_id` (FK nullable)
- `by_user_id` (FK)
- `event_type` (stage_change, note, score_update, etc.)
- `comment` (text)
- `created_at`

Relaciones:
- Application 1 ‚Äî * ApplicationHistory
- User 1 ‚Äî * ApplicationHistory (actor)

---

## Attachment (CV, archivos, grabaciones)

Campos esenciales:
- `id` (UUID)
- `owner_type` (enum: candidate/application/interview/other)
- `owner_id` (UUID)
- `filename`
- `storage_uri` (S3 signed URL)
- `content_type`
- `size`
- `hash` (para deduplicaci√≥n)
- `uploaded_by` (FK User o `system`)
- `uploaded_at`

Relaciones:
- Candidate 1 ‚Äî * Attachment
- Application 1 ‚Äî * Attachment
- Interview 1 ‚Äî * Attachment

---

## Interview

Campos esenciales:
- `id` (UUID)
- `application_id` (FK)
- `interviewer_user_id` (FK)
- `scheduled_at` (datetime)
- `duration_minutes`
- `mode` (video/phone/in-person)
- `status` (scheduled/completed/cancelled)
- `result_summary` (text)
- `recording_attachment_id` (FK Attachment)

Relaciones:
- Application 1 ‚Äî * Interview
- User 1 ‚Äî * Interview

---

## Assessment / Test (pruebas t√©cnicas, coding challenges)

Campos esenciales:
- `id` (UUID)
- `application_id` (FK)
- `type` (coding, psychometric, assignment)
- `provider` (internal/externo)
- `score` (float)
- `result_json` (jsonb)
- `taken_at`, `due_at`

Relaciones:
- Application 1 ‚Äî * Assessment

---

## CommunicationThread y Message (gesti√≥n de comunicaci√≥n candidato <-> sistema/reclutador)

CommunicationThread:
- `id` (UUID)
- `application_id` (FK)
- `channel` (email, sms, chat, portal)
- `status` (open/closed)
- `created_by` (FK User o system)
- `created_at`

Message:
- `id` (UUID)
- `thread_id` (FK)
- `sender_type` (candidate / user / system)
- `sender_id` (FK nullable)
- `content` (text / html)
- `attachments` (array/refs)
- `sent_at`
- `direction` (inbound/outbound)

Relaciones:
- Application 1 ‚Äî * CommunicationThread
- CommunicationThread 1 ‚Äî * Message

---

## Skill (cat√°logo) + CandidateSkill + VacancySkill (normalizaci√≥n de skills)

Skill:
- `id`
- `name`
- `taxonomy`
- `synonyms` (json)

CandidateSkill (join):
- `candidate_id`
- `skill_id`
- `level` (junior/medior/senior o numeric)
- `years_experience`

VacancySkill (join):
- `vacancy_id`
- `skill_id`
- `importance_weight`

Relaciones:
- Candidate * ‚Äî * Skill (v√≠a CandidateSkill)
- Vacancy * ‚Äî * Skill (v√≠a VacancySkill)

Nota: √∫til para matching sem√°ntico y filtros.

---

## Offer (propuesta salarial / contrataci√≥n)

Campos esenciales:
- `id` (UUID)
- `application_id` (FK)
- `offered_by_user_id` (FK)
- `salario_ofrecido`
- `currency`
- `terms` (json/text)
- `status` (sent / accepted / rejected / withdrawn)
- `sent_at`
- `accepted_at`

Relaciones:
- Application 1 ‚Äî * Offer
- User 1 ‚Äî * Offer

---

## Posting / ExternalPosting (publicaciones en canales externos)

Campos esenciales:
- `id` (UUID)
- `vacancy_id` (FK)
- `channel_name` (LinkedIn, Indeed, portalX)
- `external_post_id` (string)
- `status` (published/failed/removed)
- `published_at`
- `updated_at`
- `meta` (json: url, stats)

Relaciones:
- Vacancy 1 ‚Äî * Posting

---

## AuditLog (registro de acciones para cumplimiento)

Campos esenciales:
- `id` (UUID)
- `entity_type` (Candidate / Application / Vacancy / User / etc.)
- `entity_id` (UUID)
- `action` (create/update/delete/consent_change)
- `by_user_id` (FK nullable)
- `timestamp`
- `details` (json)

Relaciones:
- Log global para cualquier entidad

---

## Relaciones cardinales claves (resumen)
- Candidate 1 ‚Äî * Application  
- Vacancy 1 ‚Äî * Application  
- Application 1 ‚Äî * ApplicationHistory  
- Application 1 ‚Äî * Interview  
- Application 1 ‚Äî * Assessment  
- Application 1 ‚Äî 1..* CommunicationThread ‚Äî> * Messages  
- Candidate * ‚Äî * Skill (via CandidateSkill)  
- Vacancy * ‚Äî * Skill (via VacancySkill)  
- Vacancy 1 ‚Äî * Posting  
- Application 1 ‚Äî * Offer  
- Any Entity 1 ‚Äî * AuditLog

---

## √çndices y consideraciones pr√°cticas
- Indexar por `email` (Candidate), `vacancy_id`, `application.status + applied_at`, embeddings (usar `pgvector` o motor vectorial).
- Mantener snapshots (`resume_snapshot`, `parsed_snapshot`) en `Application` para reproducibilidad y auditor√≠a.
- `ModelVersion` / embedding metadata: almacenar `version_modelo` y `last_embedding_at` para reproducibilidad de scores.
- Privacidad: campos de consentimiento, `pii_redaction_token`, y mecanismos para `right-to-be-forgotten` (AuditLog debe soportar anonimizaci√≥n).
- Detecci√≥n de duplicados: `Attachment.hash` y comparaci√≥n de embeddings; tabla `DuplicateGroup` si quieres agrupar candidatos/attachments repetidos.

---

## Diagrama ER (Mermaid)
erDiagram
    CANDIDATE ||--o{ APPLICATION : "applies"
    VACANCY ||--o{ APPLICATION : "receives"
    USER ||--o{ VACANCY : "owns/creates"
    USER ||--o{ APPLICATION : "assigned_to"
    VACANCY ||--o{ STAGE : "defines"
    STAGE ||--o{ APPLICATION : "current_stage_of"
    APPLICATION ||--o{ APPLICATION_HISTORY : "has_events"
    USER ||--o{ APPLICATION_HISTORY : "performs"
    APPLICATION ||--o{ INTERVIEW : "has"
    USER ||--o{ INTERVIEW : "conducts"
    APPLICATION ||--o{ ASSESSMENT : "has"
    APPLICATION ||--o{ COMM_THREAD : "has"
    COMM_THREAD ||--o{ MESSAGE : "contains"
    CANDIDATE ||--o{ ATTACHMENT : "owns"
    APPLICATION ||--o{ ATTACHMENT : "has_snapshot"
    INTERVIEW ||--o{ ATTACHMENT : "may_have_recording"
    SKILL ||--o{ CANDIDATE_SKILL : "is_tag_for"
    CANDIDATE ||--o{ CANDIDATE_SKILL : "has"
    SKILL ||--o{ VACANCY_SKILL : "is_required_by"
    VACANCY ||--o{ VACANCY_SKILL : "requires"
    APPLICATION ||--o{ OFFER : "may_receive"
    VACANCY ||--o{ POSTING : "published_to"
    ANY_ENTITY ||--o{ AUDIT_LOG : "logged_in" 

    %% Entity boxes (opcional: nombres solo para referencia)
    CANDIDATE {
      string id PK
      string nombre
      string email
      text resumen_original
      json parsed_profile
    }
    VACANCY {
      string id PK
      string titulo
      text descripcion
      string estado
    }
    APPLICATION {
      string id PK
      string candidate_id FK
      string vacancy_id FK
      string status
      string current_stage_id FK
      float final_score
    }
    USER {
      string id PK
      string nombre
      string email
      string role
    }
    STAGE {
      string id PK
      string name
      int order
      string vacancy_id FK
    }
    APPLICATION_HISTORY {
      string id PK
      string application_id FK
      string from_stage_id
      string to_stage_id
      string by_user_id
      string event_type
      datetime created_at
    }
    ATTACHMENT {
      string id PK
      string owner_type
      string owner_id
      string storage_uri
      string filename
      string hash
    }
    INTERVIEW {
      string id PK
      string application_id FK
      string interviewer_user_id FK
      datetime scheduled_at
      string status
    }
    ASSESSMENT {
      string id PK
      string application_id FK
      string type
      float score
    }
    COMM_THREAD {
      string id PK
      string application_id FK
      string channel
      string status
    }
    MESSAGE {
      string id PK
      string thread_id FK
      string sender_type
      text content
      datetime sent_at
    }
    SKILL {
      string id PK
      string name
    }
    CANDIDATE_SKILL {
      string candidate_id FK
      string skill_id FK
      string level
    }
    VACANCY_SKILL {
      string vacancy_id FK
      string skill_id FK
      int weight
    }
    OFFER {
      string id PK
      string application_id FK
      float salario
      string currency
      string status
    }
    POSTING {
      string id PK
      string vacancy_id FK
      string channel_name
      string external_post_id
      string status
    }
    AUDIT_LOG {
      string id PK
      string entity_type
      string entity_id
      string action
      string by_user_id
      datetime timestamp
      json details
    }

[Diagrama ER (Mermaid)](https://mermaid.live/edit#pako:eNq1WFtP4zgU_itRpHmDmSmFofSt2waoBlrUFlazQorc5DT1kthZ2wEKw3_f46TpxUnadNFW4lL73POdW95tj_tgt20QPUoCQaJHZuGn2xn0-r3OxLHeswP9ub_v9yzqW3c_12cKXpXFeDQV4Ho8ikNQ3LiFiNDQOFMQwowzk1SATCJgLhc0oIxscP0tObNiIiT4biz4jIZgXEI0Bd-nLJDuM3iKiw3ZNAKpSBSrN8vjTALDE4q_ubu6qqAWQBSqJCq7_8j-PHQwQN1ftYKjqEpC01EfpCdo7FHODDcE_JNQSRWXhuw5FeicGxFGAhAuqro0VWmzfW4IxLMApOvDjDKqthRuehon05DK-YavNWPRubu76Xc7k_5wsC8e6ZlHmE99lGS6kN4-E7z3FqXuSZ4ID0oh40pGYjnnyk0ELUdNTrG-ZcgoqGfNNNRc6XFhCvcSIRAmbhpD0xpFVCLLQ0XiOKQ7QpnEflko78fO6H9KOME3EyYVrIBEZpynnIcWlS7xFH2Gg3AwcTq3BxhvEOawTmQJtvcrH086VzVrFYk2dFOmLC58EPthWIS7e90fT4ajX7Vgn0LCIzoBS8E9EzwqxRkWKeM4lTddlMcqZVnEBSTzCAvrgZk9mXS617fOYPJZD3cnfpXNW6mcnsyJnB_kQn8wcUYPfefPTz-jDV3SwzKZhEZ-ayj5ici4I8oSBdIwP-SZcEMtFwFh9K0K_WaxMV1zLx2n90en-7OWj2gmiGcKL6XPaN8zFKBZKyzN66lRSdMirEsVKGAeLUSF8e1I1QDmeOyMx3WAWZLyJWhbWshmNKjQ446c8f1NzTyQEqTU2XZoiPMA6p4WKrcsjssrTCNSAc5kGlFVErTh5eX-7lILBHw2g3QW2QkCEhKxcAVhAeh02EdBXkt7r7fY13bTQxow9NjnXpLGfbty7AfUyMHYjDo3tcIjAN0XFTnw2RHH8C6P1ZSzBLtyxJMDa_jdcDzpD67c7nVnMHDqObjLQG9OGIPQLckp_AGhJynqHzAqhUQi0hfMK8wTnav_mt0eD_Px_8PYZ1wUOy7I3f3AsPvuGQRKhe5Lowqx973-xL0Z1nNebzJq4W6Xs5R6eVN4FnqyK3SgGMSMiwjhM10YBScC3Ckqq00F6m6HPefGfXBG4xpbQWpWhGtoKaqyi2cQcnt10XdxImIuoTjvoxjEYgXifIhDvtg2OvvnyxdrBCHRWxlIK8Ya59GYhHl3Wi_Fv38fH_P3rdWnbT3a2dgvH-3tLbGCWoAHOGSvyNPpf0mbs2q6LMbyG39hK9p02F7SpnyaEKcjfFy4BosqE7IxWdOm6-Ba96ZtRXNXg-5Syy6u9cy4n3g9nWnafKxacayvTfr1yGMqWU8GuUGFHq5ZAmAgdFR3uVLKudujrMlquogscFzFHark6W77nY9_8hsiV1ENOVWOigr_XwStYFj1tcyip0psmm1C06_fCGDi2euivGQxSqrmCCl7Ar-EtlAri9TbJaMiZRK9yGOlSkcjnEAebfvIDgT17bYSCRzZ2C1x-cWvdlp0Hm01Bywpdgp5Ip60tg_kiQn7i_MoZxM8CeZ2e0ZCid-y7Xz5PmxFAgzXxK5uwHa72WilMuz2u_1qtxvNi68_Ls5b309PWyeN1lnzyF7Y7eNG4-zrxXmz8aPZOsGLi7Pmx5H9lqptfG2cnTbOzs8vTlrnyIDiwKeKi9vsdVz6Vu7jX3Qa2kM)



### Dise√±o del sistema a alto nivel

Arquitectura distribuida, escalable y segura que combina servicios backend independientes (microservicios o un modular monolith dividido en bounded contexts), un plano de datos relacional + vector DB para matching sem√°ntico, una capa de IA (batch + online inference), una malla de eventos para procesos as√≠ncronos y l√≠neas de integraci√≥n con canales externos (LinkedIn, portales, HRIS, video interviews).

La arquitectura satisface requisitos del documento: parsing/embeddings, scoring predictivo, automatizaci√≥n de pipeline, trazabilidad/consentimiento y facilidades de integraci√≥n.

## Visi√≥n general de alto nivel

### Frontends
* Aplicaci√≥n web para reclutadores (React/TS).
* Portal candidato p√∫blico (responsive).
* Consola Admin y dashboards anal√≠ticos.

### API Gateway / BFF
* Punto √∫nico para autenticaci√≥n, throttling, versionado y enrutado a microservicios.

### Microservicios (o m√≥dulos aut√≥nomos)
* Auth & Identity
* User & Team Management
* Vacancy Service
* Candidate Service
* Application Service (pipeline + ApplicationHistory)
* Attachment Service (S3 presigned URLs)
* Parsing / Resume Processor (OCR, NLP)
* Scoring & Matching (inference service)
* Vector Store / Semantic Search (pgvector, Milvus o Pinecone)
* Interview & Calendar Service
* Notification / Messaging (email, SMS, chatbot)
* Integration / Connector Service (LinkedIn, ATSs, job-boards)
* Analytics / BI & Reporting
* Model Training / ML Platform
* Audit / Compliance Service

### Infra / infra-as-code
* Kubernetes (EKS/GKE/AKS) + Helm
* Object storage (S3 / MinIO)
* DB: PostgreSQL (+ pgvector) o Postgres + vector DB
* Message broker: Kafka (event streaming) o RabbitMQ (mensajer√≠a)
* Cache: Redis
* CI/CD: GitHub Actions / GitLab CI -> deploy pipelines
* Observabilidad: Prometheus, Grafana, Jaeger, ELK / Loki

## Distribuci√≥n de componentes y responsabilidad

### API Gateway / BFF
* Exponer REST/GraphQL al frontend.
* Autenticaci√≥n (OAuth2 / OIDC), rate limiting, CORS, TLS.
* Traduce contratos a llamadas internas (gRPC / HTTP).

### Auth & Identity
* RBAC, SSO (SAML/OKTA), gesti√≥n de sesiones, MFA.
* Emite JWT con scopes y tenant/organization claims.

### User & Team Management
* CRUD de usuarios, equipos, roles; integraci√≥n con HRIS.
* Conecta con Vacancy Service para ownership.

### Vacancy Service
* Modelo de vacante, stages_definition, publishing workflow.
* Orquesta PostingChannel (a trav√©s del Integration Service).
* Emite eventos: `vacancy.created`/`published`/`closed`.

### Candidate Service
* CRUD candidato, consentimiento, raw_resume_text, parsed_profile referencia.
* Mantiene `last_embedding_model_version_id`.
* Indices para email, dedup hashes.

### Application Service
* Registro de postulaci√≥n, estado actual, final_score, `assigned_recruiter_id`.
* Guarda ApplicationHistory, emite eventos `application.*`.
* Implementa reglas de negocio (duplicate detection, auto-move rules).

### Attachment Service
* Presigned URLs a S3, deduplicaci√≥n por hash, virus-scan (clamav) en pipeline.

### Parsing / Resume Processor (Worker)
* Cola de trabajos: `resume.uploaded` -> OCR/NLP -> `parsed_snapshot` -> store.
* Utiliza modelos de extracci√≥n (spaCy, Transformers) y normalizadores.
* Emite `resume.parsed` y updates a Candidate/Application.

### Scoring & Matching (Inference)
* Servicio de inferencia (gRPC/HTTP) que recibe `parsed_profile`/embeddings y devuelve scores (technical, cultural, final) y explanations (shap/lime style).
* Consume modelos versionados; registra `ModelVersion used`.
* Puede ofrecer inferences s√≠ncronas (para UI) y bajo demanda (re-score batch).

### Vector Store / Semantic Search
* Guarda embeddings para b√∫squeda sem√°ntica y nearest-neighbors.
* Indexaci√≥n incremental, nearest neighbor queries para sourcing y matching.

### Interview & Calendar
* Integraci√≥n con calendarios (Google / Outlook), generaci√≥n de links video, gesti√≥n de participantes y entrevista.feedback.
* Publica `interview.scheduled` / `interview.completed`.

### Notification / Messaging
* Envia emails, SMS, mensajes a chatbot y notificaciones in-app.
* Template engine y personalizaci√≥n.
* Gestiona retries, delivery reports.

### Integration / Connector Service
* Connectors para LinkedIn, Indeed, portales locales, HRIS (Workday, SAP SF).
* Implementa pub/sub y webhooks; mantiene `external_id` mapping (`PostingChannel.external_id`).

### Analytics / BI
* Data pipeline ETL -> Data Warehouse (BigQuery/Redshift) para KPIs: time-to-hire, NPS, automation rate.
* Alerts y ML-driven signals (cuellos de botella, forecast).

### Model Training / ML Platform
* Pipeline de entrenamiento reproducible (MLflow, Kubeflow).
* Dataset versioning, feature store, retraining scheduler.
* Promueve modelos al Model Registry y despliegue a inference service.

### Audit / Compliance
* Centraliza AuditLog / ConsentRecord.
* Provee endpoints para data redaction y export (GDPR).

## Patrones de comunicaci√≥n

### S√≠ncrono
* REST/GraphQL para frontends y partners con control de latencia.
* gRPC entre microservicios que requieran llamadas de baja latencia y contratos fuertemente tipados (por ejemplo: User Service <-> Vacancy Service <-> Application Service).
* Uso de circuit breaker (eg. Resilience4j), timeouts y retries limitados.

### As√≠ncrono / Event-driven
* Message broker (Kafka preferido para streams; RabbitMQ si se necesitan colas simples).
* Temas/eventos clave:
    * `vacancy.created`, `vacancy.published`, `vacancy.closed`
    * `candidate.created`, `candidate.updated`
    * `resume.uploaded`, `resume.parsed`
    * `application.created`, `application.stage_changed`, `application.scored`
    * `interview.scheduled`, `interview.completed`
    * `offer.created`, `offer.sent`, `offer.accepted`
    * `notification.sent`
* Consumers: Parsing workers, Scoring service, Notification service, Analytics ETL, Integration connectors.
* Ventajas: desacoplamiento, resiliencia, escala horizontal de workers, reprocessabilidad.

### Pub/Sub + Webhooks
* Para integraciones externas y partners: publicar webhooks (secure HMAC, rate-limited, retry/backoff).
* Soportar contratos versionados y delivery status.

### Command / Event pattern
* Commands para acciones que requieren autorizaci√≥n y workflow (eg. `publishVacancy`), events para notificar.
* Implementar idempotencia en handlers (message idempotency keys).

### CQRS + Event Sourcing (opcional, recomendado para partes)
* Separar write model (services) del read model (materialized views para UI).
* Event store para ApplicationHistory y auditor√≠a. Facilita reconstrucci√≥n de pipeline, reproducibilidad y KPIs.
* Read-models actualizados por consumers para optimizar queries de UI.

### Long-running workflows / Sagas
* Para procesos compuestos (e.g., flujo de aprobaci√≥n de ofertas), aplicar Saga pattern or workflow engine (Temporal, Cadence) para garantizar consistencia eventual y manejo de compensaciones.

## Flujos cr√≠ticos (secuencias resumidas)

### Crear y publicar vacante
1.  Reclutador -> API Gateway -> Vacancy Service (sync persist).
2.  Vacancy Service publica `vacancy.created`, `vacancy.published`.
3.  Integration Service consume y publica en canales externos; updates via `posting_channel` events.
4.  Analytics recibe eventos para reporting.

### Candidato se postula
1.  Candidate/Portal -> Application Service crea `application` (persist), stores resume to Attachment Service.
2.  Application Service emite `application.created`, `resume.uploaded`.
3.  Parsing worker lee `resume.uploaded` -> `resume.parsed` -> updates Candidate and Application (`parsed_snapshot`), emits `resume.parsed`.
4.  Scoring service subscribes to `resume.parsed`/`application.created` -> computes scores -> emits `application.scored`.
5.  Notification service env√≠a confirmaci√≥n.

### Evaluar y mover pipeline
1.  Recruiter en UI solicita list/filters -> read-model query (fast).
2.  Recruiter mueve candidato -> command `application.move_stage`; Application Service persists, emits `application.stage_changed`; ApplicationHistory entry inserta.
3.  Notification service notifica candidato y optionally triggers automations.

### Entrevista y feedback
1.  Interview scheduled -> `interview.scheduled` event.
2.  Interview feedback saved -> `interview.feedback.created` -> updates application, affects `final_score` (scoring service or aggregator).

## Modelos de datos y persistencia (resumen)
* **RDBMS principal:** PostgreSQL para entities (Candidate, Vacancy, Application, User, Stage, ApplicationHistory, ModelVersion).
* **Vector DB / pgvector:** embeddings, nearest neighbors, semantic search.
* **Object storage:** S3 para attachments, signed URLs.
* **Event streaming:** Kafka for events (topic-per-entity or topic-per-action).
* **Cache:** Redis para sessions, rate-limiting, hot results.
* **Data Warehouse:** para analytics y ML training (export v√≠a Kafka Connect).

## Seguridad, privacidad y cumplimiento
* Encriptaci√≥n TLS everywhere; at-rest encryption for DB and S3.
* RBAC y scopes en JWT; admins y roles definidos (recruiter, hiring_manager, admin, sourcer).
* **Consentimiento y Data Subject Requests:**
    * Guardar ConsentRecord.
    * Endpoints para export/delete (right-to-be-forgotten) que ponen en cola procesos de redaction (anonymize blobs, remove from search index, revoke embeddings).
* PII redaction token y masking en logs.
* Registro de auditor√≠a de operaciones sensibles (AuditLog service).
* Secrets management (HashiCorp Vault / cloud KMS).
* Rate limiting, WAF, CSP.

## Observabilidad y resiliencia
* Telemetr√≠a: OpenTelemetry tracing + Jaeger; metrics Prometheus + Grafana.
* Centralized logging (ELK / Loki).
* Health checks, readiness, liveness para Kubernetes.
* Circuit breakers, retries exponenciados y cabeceras `idempotency-key`.
* Chaos testing y SLOs para time-to-score, API latency.

## Operaciones y ML Ops
* CI/CD pipelines: lint -> tests -> build -> image -> canary/cutover deploy.
* DB migrations con versionado (Flyway / Liquibase).
* MLflow / Kubeflow para ciclo de vida de modelos; versionar dataset y modelos (`ModelVersion` table).
* Retraining scheduler y shadow testing antes de promover modelos al inference endpoint.

## Patr√≥n de decisi√≥n t√©cnica / trade-offs

### Microservicios vs modular monolith
* Monolith modular si equipo peque√±o: menor complejidad operativa.
* Microservicios si necesidad de escalar componentes (parsing, scoring, vector DB) independientemente.

### Vector DB choices
* `pgvector` (con Postgres) para simplicidad; Milvus/Pinecone para escala y latencias en NN.

### Message broker
* Kafka para arquitecturas event-driven con alto throughput y replay.
* RabbitMQ si prefieres control de colas y patterns RPC/ack m√°s simples.

### CQRS/Event Sourcing
* Agrega complejidad pero rentable para historiales y re-scores/rec√°lculos.


[Ver diagrama](images/disenio_de_alto_nivel.png)


### Diagrama C4:

 Diagrama C4 en PlantUML que incluye tres vistas: contexto del sistema, contenedores principales y un desglose en componentes del servicio Parsing / Resume Processor.

 [Ver diagrama](images/c4.png)